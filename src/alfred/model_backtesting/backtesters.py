import pandas as pd
import numpy as np

"""
Pretty cool, I wrote a quick version of this and then got gemini to refactor it into a 
documented class with only 3-4 review iterations. 
"""

class BackTester:
    """
    Base class for backtesting strategies. Provides common functionality for running backtests and analyzing results.
    Provides default implementations for operation methods (open_long, close_long, etc.).
    Subclasses should implement the run_test method to define specific signal logic.
    """

    def __init__(self):
        """
        Initializes the BackTester with an empty ledger and no current operation.
        """
        self.ledger = []
        self.current_operation = None
        self.entry_price = None

    def run_test(self, df, entries, model_readings):
        """
        Abstract method to run the backtest. Must be implemented by subclasses to define specific signal logic.

        Args:
            df (pd.DataFrame): DataFrame with price data (must have 'Close' column and Date index).
            entries (np.array): Array of signals for each date in the DataFrame.
            model_readings (np.array): Array of model readings for each date in the DataFrame (for logging).

        Returns:
            pd.DataFrame: Ledger DataFrame containing trade history.
        """
        raise NotImplementedError("Subclasses must implement the run_test method.")

    def _log_operation(self, date, operation, price=None, profit=None, reading=None):
        """
        Helper function to log operations with consistent formatting and ledger updates.

        Args:
            date (Index): Date of the operation.
            operation (str): Name of the operation (e.g., 'BUY', 'CLOSE_LONG').
            price (float, optional): Entry or exit price. Defaults to None.
            profit (float, optional): Profit of a closed trade. Defaults to None.
            reading (float, optional): Model reading at the time of operation. Defaults to None.
        """
        log_message = f"{date}, {operation}"
        if price is not None:
            log_message += f", Price={price:.2f}"
        if profit is not None:
            log_message += f", Profit={profit:.2f}"
        if reading is not None:
            log_message += f", Model Reading={reading}"
        print(log_message)

    def print_ledger_metrics(self, df, ledger):
        """
        Calculates and prints buy/hold profit and win/loss rate from a backtest ledger.

        Args:
            df (pd.DataFrame): Original DataFrame with price data (must have 'Close' column and Date index).
            ledger (pd.DataFrame): Ledger DataFrame generated by run_test function.
        """

        print("\n--- Ledger Metrics ---")

        # 1. Buy and Hold Profit Calculation
        first_date = df.index.min()
        last_date = df.index.max()
        first_close = df.loc[first_date]['Close']
        last_close = df.loc[last_date]['Close']
        buy_hold_profit = last_close - first_close

        print("\nBuy and Hold Strategy (First to Last Date):")
        print(f"  Start Date: {first_date.date()}, Close Price: {first_close:.2f}")
        print(f"  End Date: {last_date.date()}, Close Price: {last_close:.2f}")
        print(f"  Buy & Hold Profit (per unit): {buy_hold_profit:.2f}")

        # 2. Win/Loss Rate Calculation
        closed_trades = ledger[ledger['exit_price'].notna()] # Filter for closed trades (exit_price is not NaN)
        if not closed_trades.empty:
            profitable_trades = closed_trades[closed_trades['profit'] > 0]
            losing_trades = closed_trades[closed_trades['profit'] < 0]
            win_rate = len(profitable_trades) / len(closed_trades) if len(closed_trades) > 0 else 0
            loss_rate = len(losing_trades) / len(closed_trades) if len(losing_trades) > 0 else 0

            print("\nWin/Loss Rate (from Ledger):")
            print(f"  Total Closed Trades: {len(closed_trades)}")
            print(f"  Profitable Trades: {len(profitable_trades)}")
            print(f"  Losing Trades: {len(losing_trades)}")
            print(f"  Win Rate: {win_rate:.2%}")
            print(f"  Loss Rate: {loss_rate:.2%}")
            aggregate_profit = closed_trades['profit'].sum()
            print(f"\nAggregate Profit (from all closed trades): {aggregate_profit:.2f}")

        else:
            print("\nNo closed trades in ledger to calculate win/loss rate.")


    def open_long(self, date, close, reading):
        operation = 'BUY'
        self.entry_price = close
        self.current_operation = 'long'
        self.ledger.append({'Date': date, 'operation': operation, 'entry_price': self.entry_price, 'exit_price': None, 'profit': None})
        self._log_operation(date, f"{operation} CREATE", price=self.entry_price, reading=reading)

    def close_long(self, date, close, reading):
        exit_price = close
        profit = exit_price - self.entry_price # Profit for long is exit - entry
        operation = 'CLOSE_LONG'
        self.ledger.append({'Date': date, 'operation': operation, 'entry_price': None, 'exit_price': exit_price, 'profit': profit})
        self.current_operation = None
        self._log_operation(date, operation, price=exit_price, profit=profit, reading=reading)

    def open_short(self, date, close, reading):
        operation = 'SELL_SHORT'
        self.entry_price = close
        self.current_operation = 'short'
        self.ledger.append({'Date': date, 'operation': operation, 'entry_price': self.entry_price, 'exit_price': None, 'profit': None})
        self._log_operation(date, f"{operation} CREATE", price=self.entry_price, reading=reading)

    def close_short(self, date, close, reading):
        exit_price = close
        profit = self.entry_price - exit_price # Profit for short is entry - exit
        operation = 'CLOSE_SHORT'
        self.ledger.append({'Date': date, 'operation': operation, 'entry_price': None, 'exit_price': exit_price, 'profit': profit})
        self.current_operation = None
        self._log_operation(date, operation, price=exit_price, profit=profit, reading=reading)

    def hold_long(self, date, close, reading):
        self._log_operation(date, "HOLD_LONG", price=close, reading=reading)

    def hold_short(self, date, close, reading):
        self._log_operation(date, "HOLD_SHORT", price=close, reading=reading)


class SimpleBacktester(BackTester):
    """
    Implements a simple backtesting strategy that goes long on signal 1 and short on signal 0,
    reversing positions when the opposite signal is encountered.
    """

    def run_test(self, df, entries, model_readings):
        """
        Runs the simple signal backtest as defined in run_basic_signal_backtest.

        Args:
            df (pd.DataFrame): DataFrame with price data.
            entries (np.array): Array of signals (1 for long, 0 for short).
            model_readings (np.array): Array of model readings.

        Returns:
            pd.DataFrame: Ledger DataFrame.
        """
        assert len(df.index) == len(entries)
        assert len(entries) == len(model_readings)
        self.ledger = [] # Reset ledger for each run
        self.current_operation = None
        self.entry_price = None

        for (date, row), entry, reading in zip(df.iterrows(), entries, model_readings):
            close = row["Close"]
            if self.current_operation is None: # No open position
                if entry == 1: # Buy signal
                    self.open_long(date, close, reading)
                elif entry == 0: # Sell signal (for short)
                    self.open_short(date, close, reading)
            elif self.current_operation == 'short': # Currently short
                if entry == 1: # Buy signal (close short and go long)
                    self.close_short(date, close, reading)
                    self.open_long(date, close, reading)
                elif entry == 0: # Sell signal (hold short)
                    self.hold_short(date, close, reading)
            elif self.current_operation == 'long': # Currently long
                if entry == 0: # Sell signal (close long and go short)
                    self.close_long(date, close, reading)
                    self.open_short(date, close, reading)
                elif entry == 1: # Buy signal (hold long)
                    self.hold_long(date, close, reading)

        ledger_df = pd.DataFrame(self.ledger)
        return ledger_df


class NuancedBacktester(BackTester):
    """
    Implements a nuanced backtesting strategy with more signal types:
    2 - confident long, 1 - close short, 0 - unsure, -1 - close long, -2 - confident short.
    """

    def run_test(self, df, entries, model_readings):
        """
        Runs the nuanced signal backtest as defined in run_nuanced_signal_backtest.

        Args:
            df (pd.DataFrame): DataFrame with price data.
            entries (np.array): Array of nuanced signals (2, 1, 0, -1, -2).
            model_readings (np.array): Array of model readings.

        Returns:
            pd.DataFrame: Ledger DataFrame.
        """
        assert len(df.index) == len(entries)
        assert len(entries) == len(model_readings)
        self.ledger = [] # Reset ledger for each run
        self.current_operation = None
        self.entry_price = None

        for (date, row), entry, reading in zip(df.iterrows(), entries, model_readings):
            close = row["Close"]
            if self.current_operation is None: # No open position
                if entry == 2: # Confident long
                    self.open_long(date, close, reading)
                elif entry == -2: # Confident short
                    self.open_short(date, close, reading)
            elif self.current_operation == 'short': # Currently short
                if entry > 0: # Close short (signals 1 or 2)
                    self.close_short(date, close, reading)
                    if entry == 2: # If confident long signal, go long immediately after closing short
                        self.open_long(date, close, reading) # Open long after close short
                elif entry <= 0: # Stay short (signals 0, -1, -2)
                    self.hold_short(date, close, reading)
            elif self.current_operation == 'long': # Currently long
                if entry < 0: # Close long (signals -1 or -2)
                    self.close_long(date, close, reading)
                    if entry == -2: # If confident short signal, go short immediately after closing long
                         self.open_short(date, close, reading) # Open short after close long
                elif entry >= 0 : # Hold long on signal > 0
                    self.hold_long(date, close, reading)

        ledger_df = pd.DataFrame(self.ledger)
        return ledger_df