import pandas as pd
import numpy as np
from numexpr.necompiler import long_

"""
Pretty cool, I wrote a quick version of this and then got gemini to refactor it into a 
documented class with only 3-4 review iterations. 
"""


class BackTester:
    """
    Base class for backtesting strategies. Provides common functionality for running backtests and analyzing results.
    Provides default implementations for operation methods (open_long, close_long, etc.).
    Subclasses should implement the run_test method to define specific signal logic.
    """

    def __init__(self):
        """
        Initializes the BackTester with an empty ledger and no current operation.
        """
        self.ledger = []
        self.current_operation = None
        self.entry_price = None

    def run_test(self, df, entries, model_readings):
        """
        Abstract method to run the backtest. Must be implemented by subclasses to define specific signal logic.

        Args:
            df (pd.DataFrame): DataFrame with price data (must have 'Close' column and Date index).
            entries (np.array): Array of signals for each date in the DataFrame.
            model_readings (np.array): Array of model readings for each date in the DataFrame (for logging).

        Returns:
            pd.DataFrame: Ledger DataFrame containing trade history.
        """
        raise NotImplementedError("Subclasses must implement the run_test method.")

    def _log_operation(self, date, operation, price=None, profit=None, reading=None):
        """
        Helper function to log operations with consistent formatting and ledger updates.

        Args:
            date (Index): Date of the operation.
            operation (str): Name of the operation (e.g., 'BUY', 'CLOSE_LONG').
            price (float, optional): Entry or exit price. Defaults to None.
            profit (float, optional): Profit of a closed trade. Defaults to None.
            reading (float, optional): Model reading at the time of operation. Defaults to None.
        """
        log_message = f"{date}, {operation}"
        if price is not None:
            log_message += f", Price={price:.2f}"
        if profit is not None:
            log_message += f", Profit={profit:.2f}"
        if reading is not None:
            log_message += f", Model Reading={reading}"
        print(log_message)

    def print_ledger_metrics(self, df, ledger):
        """
        Calculates and prints buy-and-hold return percentage and invokes trade analysis from a backtest ledger.

        Args:
            df (pd.DataFrame): DataFrame with price data (must have 'Close' column and Date index).
            ledger (pd.DataFrame): Ledger DataFrame generated by run_test function.
        """
        print("\n--- Ledger Metrics ---")

        # Buy and Hold Return Calculation
        first_close = df['Close'].iloc[0]
        last_close = df['Close'].iloc[-1]
        buy_hold_return_pct = (last_close / first_close - 1) * 100 if first_close != 0 else 0

        print("\nBuy and Hold Strategy (First to Last Date):")
        print(f"  Start Date: {df.index[0].date()}, Close Price: {first_close:.2f}")
        print(f"  End Date: {df.index[-1].date()}, Close Price: {last_close:.2f}")
        print(f"  Buy & Hold Return: {buy_hold_return_pct:.2f}%")

        # Invoke trade analysis
        self.print_ledger(ledger)

    def print_ledger(self, ledger):
        """
        Analyzes the ledger to calculate and print trade statistics with profits as percentages.

        Args:
            ledger (pd.DataFrame): Ledger DataFrame containing trade history.
        """
        print("\n--- Trade Analysis ---")

        # Filter closing operations
        closing_operations = ledger[ledger['operation'].isin(['CLOSE_LONG', 'CLOSE_SHORT'])].copy()

        if closing_operations.empty:
            print("No completed trades in ledger.")
            return

        # Calculate profit percentage for each closing operation
        closing_operations['profit_pct'] = (closing_operations['profit'] / closing_operations['entry_price']) * 100
        closing_operations['profit_pct'] = closing_operations['profit_pct'].fillna(0)

        # Compute statistics
        profitable_trades = closing_operations[closing_operations['profit'] > 0]
        losing_trades = closing_operations[closing_operations['profit'] < 0]
        win_rate = len(profitable_trades) / len(closing_operations) if len(closing_operations) > 0 else 0
        average_profit_pct = closing_operations['profit_pct'].mean()
        total_profit_pct = closing_operations['profit_pct'].sum()  # Sum of per-trade percentages
        aggregate_profit = closing_operations['profit'].sum()  # Absolute profit for reference

        # Print trade statistics
        print(f"Total Completed Trades: {len(closing_operations)}")
        print(f"Profitable Trades: {len(profitable_trades)}")
        print(f"Losing Trades: {len(losing_trades)}")
        print(f"Win Rate: {win_rate:.2%}")
        print(f"Average Profit Percentage per Trade: {average_profit_pct:.2f}%")
        print(f"Total Profit Percentage (sum of trade %): {total_profit_pct:.2f}%")

    def open_long(self, date, close, reading):
        operation = 'BUY'
        self.entry_price = close
        self.current_operation = 'long'
        self.ledger.append(
            {'Date': date, 'operation': operation, 'entry_price': self.entry_price, 'exit_price': None, 'profit': None})
        self._log_operation(date, f"{operation} CREATE", price=self.entry_price, reading=reading)

    def close_long(self, date, close, reading):
        exit_price = close
        profit = exit_price - self.entry_price  # Profit for long is exit - entry
        operation = 'CLOSE_LONG'
        self.ledger.append(
            {'Date': date, 'operation': operation, 'entry_price': self.entry_price, 'exit_price': exit_price, 'profit': profit})
        self.current_operation = None
        self._log_operation(date, operation, price=exit_price, profit=profit, reading=reading)

    def open_short(self, date, close, reading):
        operation = 'SELL_SHORT'
        self.entry_price = close
        self.current_operation = 'short'
        self.ledger.append(
            {'Date': date, 'operation': operation, 'entry_price': self.entry_price, 'exit_price': None, 'profit': None})
        self._log_operation(date, f"{operation} CREATE", price=self.entry_price, reading=reading)

    def close_short(self, date, close, reading):
        exit_price = close
        profit = self.entry_price - exit_price  # Profit for short is entry - exit
        operation = 'CLOSE_SHORT'
        self.ledger.append(
            {'Date': date, 'operation': operation, 'entry_price': self.entry_price, 'exit_price': exit_price, 'profit': profit})
        self.current_operation = None
        self._log_operation(date, operation, price=exit_price, profit=profit, reading=reading)

    def hold_long(self, date, close, reading):
        self._log_operation(date, "HOLD_LONG", price=close, reading=reading)

    def hold_short(self, date, close, reading):
        self._log_operation(date, "HOLD_SHORT", price=close, reading=reading)


class SimpleBacktester(BackTester):
    """
    Implements a simple backtesting strategy that goes long on signal 1 and short on signal 0,
    reversing positions when the opposite signal is encountered.
    """

    def run_test(self, df, entries, model_readings):
        """
        Runs the simple signal backtest as defined in run_basic_signal_backtest.

        Args:
            df (pd.DataFrame): DataFrame with price data.
            entries (np.array): Array of signals (1 for long, 0 for short).
            model_readings (np.array): Array of model readings.

        Returns:
            pd.DataFrame: Ledger DataFrame.
        """
        assert len(df.index) == len(entries)
        assert len(entries) == len(model_readings)
        self.ledger = []  # Reset ledger for each run
        self.current_operation = None
        self.entry_price = None

        for (date, row), entry, reading in zip(df.iterrows(), entries, model_readings):
            close = row["Close"]
            if self.current_operation is None:  # No open position
                if entry == 1:  # Buy signal
                    self.open_long(date, close, reading)
                elif entry == 0:  # Sell signal (for short)
                    self.open_short(date, close, reading)
            elif self.current_operation == 'short':  # Currently short
                if entry == 1:  # Buy signal (close short and go long)
                    self.close_short(date, close, reading)
                    self.open_long(date, close, reading)
                elif entry == 0:  # Sell signal (hold short)
                    self.hold_short(date, close, reading)
            elif self.current_operation == 'long':  # Currently long
                if entry == 0:  # Sell signal (close long and go short)
                    self.close_long(date, close, reading)
                    self.open_short(date, close, reading)
                elif entry == 1:  # Buy signal (hold long)
                    self.hold_long(date, close, reading)

        ledger_df = pd.DataFrame(self.ledger)
        return ledger_df


class NuancedBacktester(BackTester):
    """
    Implements a nuanced backtesting strategy with more signal types:
    2 - confident long, 1 - close short, 0 - unsure, -1 - close long, -2 - confident short.
    """

    def run_test(self, df, entries, model_readings):
        """
        Runs the nuanced signal backtest as defined in run_nuanced_signal_backtest.

        Args:
            df (pd.DataFrame): DataFrame with price data.
            entries (np.array): Array of nuanced signals (2, 1, 0, -1, -2).
            model_readings (np.array): Array of model readings.

        Returns:
            pd.DataFrame: Ledger DataFrame.
        """
        assert len(df.index) == len(entries)
        assert len(entries) == len(model_readings)
        self.ledger = []  # Reset ledger for each run
        self.current_operation = None
        self.entry_price = None

        for (date, row), entry, reading in zip(df.iterrows(), entries, model_readings):
            close = row["Close"]
            if self.current_operation is None:  # No open position
                if entry == 2:  # Confident long
                    self.open_long(date, close, reading)
                elif entry == -2:  # Confident short
                    self.open_short(date, close, reading)
            elif self.current_operation == 'short':  # Currently short
                if entry > 0:  # Close short (signals 1 or 2)
                    self.close_short(date, close, reading)
                    if entry == 2:  # If confident long signal, go long immediately after closing short
                        self.open_long(date, close, reading)  # Open long after close short
                elif entry <= 0:  # Stay short (signals 0, -1, -2)
                    self.hold_short(date, close, reading)
            elif self.current_operation == 'long':  # Currently long
                if entry < 0:  # Close long (signals -1 or -2)
                    self.close_long(date, close, reading)
                    if entry == -2:  # If confident short signal, go short immediately after closing long
                        self.open_short(date, close, reading)  # Open short after close long
                elif entry >= 0:  # Hold long on signal > 0
                    self.hold_long(date, close, reading)

        ledger_df = pd.DataFrame(self.ledger)
        return ledger_df


class MagnitudeChoiceBacktester(BackTester):
    def __init__(self):
        super().__init__()
        self.current_instrument = None

    def print_ledger_metrics(self, df, ledger):
        """
        Calculates and prints basket buy-and-hold return percentage and invokes base class trade analysis.

        Args:
            df (pd.DataFrame): DataFrame with price data (must have 'Close' and 'ticker' columns).
            ledger (pd.DataFrame): Ledger DataFrame generated by run_test function.
        """
        print("\n--- Basket Hold Metrics ---")

        # Calculate Equal-Weighted Buy and Hold Return for the Entire Basket
        unique_tickers = df['ticker'].unique()
        buy_hold_returns = []

        for ticker in unique_tickers:
            ticker_data = df[df['ticker'] == ticker]
            if not ticker_data.empty:
                first_close = ticker_data['Close'].iloc[0]
                last_close = ticker_data['Close'].iloc[-1]
                if first_close != 0:  # Avoid division by zero
                    ticker_return = (last_close / first_close - 1) * 100
                    buy_hold_returns.append(ticker_return)

        if buy_hold_returns:
            avg_buy_hold_return_pct = np.mean(buy_hold_returns)
            print("\nEqual-Weighted Buy and Hold Return (Entire Basket):")
            print(f"  Average Return: {avg_buy_hold_return_pct:.2f}%")

        # Call base class method for trade analysis
        super().print_ledger(ledger)

    def open_long(self, date, close, reading, asset=None):
        super().open_long(date, close, reading)
        self.current_instrument = asset
        print("Asset:", asset)

    def close_long(self, date, close, reading):
        super().close_long(date, close, reading)
        print("Asset:", self.current_instrument)
        self.current_instrument = None

    def open_short(self, date, close, reading, asset=None):
        super().open_short(date, close, reading)
        self.current_instrument = asset
        print("Asset:", asset)

    def close_short(self, date, close, reading):
        super().close_short(date, close, reading)
        print("Asset:", self.current_instrument)
        self.current_instrument = None

    def hold_long(self, date, close, reading):
        self._log_operation(date, f"HOLD_LONG {self.current_instrument}", price=close, reading=reading)

    def hold_short(self, date, close, reading):
        self._log_operation(date, f"HOLD_SHORT {self.current_instrument}", price=close, reading=reading)

    def run_test(self, df):
        for date, group in df.groupby(level=0):
            highest = group.nlargest(1, 'predictions')
            lowest = group.nsmallest(1, 'predictions')

            if abs(highest["predictions"].iloc[0]) >= abs(lowest["predictions"].iloc[0]):
                action = "long"
                instrument = highest["ticker"].iloc[0]
                data = highest
            else:
                action = "short"
                instrument = lowest["ticker"].iloc[0]
                data = lowest

            if self.current_instrument is not None and (
                    self.current_instrument != instrument or self.current_operation != action):
                close_row = group[group['ticker'] == self.current_instrument]
                if close_row.empty:
                    raise Exception(f"Data error, no data for {self.current_instrument} on {date}")
                close = close_row['Close'].iloc[0]
                reading = close_row['predictions'].iloc[0]
                if self.current_operation == "long":
                    self.close_long(date, close, reading)
                elif self.current_operation == "short":
                    self.close_short(date, close, reading)

            if self.current_operation == action and self.current_instrument == instrument:
                close = data['Close'].iloc[0]
                reading = data['predictions'].iloc[0]
                if action == "long":
                    self.hold_long(date, close, reading)
                elif action == "short":
                    self.hold_short(date, close, reading)
            else:
                close = data['Close'].iloc[0]
                reading = data['predictions'].iloc[0]
                if action == "long":
                    self.open_long(date, close, reading, asset=instrument)
                elif action == "short":
                    self.open_short(date, close, reading, asset=instrument)

        # Close final position
        if self.current_instrument is not None:
            last_date = df.index.max()
            close_row = df[(df.index == last_date) & (df['ticker'] == self.current_instrument)]
            if not close_row.empty:
                close = close_row['Close'].iloc[0]
                reading = close_row['predictions'].iloc[0]
                if self.current_operation == "long":
                    self.close_long(last_date, close, reading)
                elif self.current_operation == "short":
                    self.close_short(last_date, close, reading)

        return pd.DataFrame(self.ledger)
